<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="DependentAsyncTasking" kind="page">
    <compoundname>DependentAsyncTasking</compoundname>
    <title>Asynchronous Tasking with Dependencies</title>
    <tableofcontents>
      <tocsect>
        <name>Create a Task Graph Dynamically</name>
        <reference>DependentAsyncTasking_1CreateATaskGraphDynamically</reference>
    </tocsect>
    </tableofcontents>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This chapters discusses how to create a task graph dynamically using asynchronous tasks, which is extremely beneficial for workloads that want to (1) explore task graph parallelism out of dynamic control flow or (2) overlap task graph creation time with individual task execution time. We recommend that you first read <ref refid="AsyncTasking" kindref="compound">Asynchronous Tasking</ref> before this chapter.</para>
<sect1 id="DependentAsyncTasking_1CreateATaskGraphDynamically">
<title>Create a Task Graph Dynamically</title>
<para>When the construct-and-run model of a task graph is not possible in your application, you can use <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> and <ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">tf::Executor::silent_dependent_async</ref> to create a task graph dynamically. This type of parallelism is also known as <emphasis>on-the-fly task graph parallelism</emphasis>, which offers great flexibility for expressing dynamic task parallelism. The example below dynamically creates a task graph of four dependent tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, <computeroutput>C</computeroutput>, and <computeroutput>D</computeroutput>, where <computeroutput>A</computeroutput> runs before <computeroutput>B</computeroutput> and <computeroutput>C</computeroutput> and <computeroutput>D</computeroutput> runs after <computeroutput>B</computeroutput> and <computeroutput>C:</computeroutput> </para>
<para><dotfile name="simple.dot"></dotfile>
</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">silent_dependent_async</ref>([](){<sp/>printf(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">silent_dependent_async</ref>([](){<sp/>printf(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>C<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[D,<sp/>fuD]<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;D\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>B,<sp/>C);</highlight></codeline>
<codeline><highlight class="normal">D.get();<sp/><sp/></highlight><highlight class="comment">//<sp/>wait<sp/>for<sp/>D<sp/>to<sp/>finish,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>A,<sp/>B,<sp/>C<sp/>finish</highlight></codeline>
</programlisting></para>
<para>Both <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> and <ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">tf::Executor::silent_dependent_async</ref> create a task of type <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> to run the given function asynchronously. Additionally, <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> returns a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that eventually holds the result of the execution. When returning from both calls, the executor has scheduled a worker to run the task whenever its dependencies are met. That is, task execution happens <emphasis>simultaneously</emphasis> with the creation of the task graph, which is different from constructing a Taskflow and running it from an executor.</para>
<para>Since this model only allows relating a dependency from the current task to a previously created task, you need a correct topological order of graph expression. In our example, there are only two possible topological orderings, either <computeroutput>ABCD</computeroutput> or <computeroutput>ACBD</computeroutput>. The code below shows another feasible order of expressing this dynamic task graph parallelism.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">silent_dependent_async</ref>([](){<sp/>printf(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>C<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">silent_dependent_async</ref>([](){<sp/>printf(</highlight><highlight class="stringliteral">&quot;C\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[D,<sp/>fuD]<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;D\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>B,<sp/>C);</highlight></codeline>
<codeline><highlight class="normal">D.get();<sp/><sp/></highlight><highlight class="comment">//<sp/>wait<sp/>for<sp/>D<sp/>to<sp/>finish,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>A,<sp/>B,<sp/>C<sp/>finish</highlight></codeline>
</programlisting> </para>
</sect1>
    </detaileddescription>
    <location file="cookbook/dependent_async_tasking.dox"/>
  </compounddef>
</doxygen>
