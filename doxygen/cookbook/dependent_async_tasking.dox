namespace tf {

/** @page DependentAsyncTasking Asynchronous Tasking with Dependencies

This chapters discusses how to create a task graph dynamically 
using asynchronous tasks,
which is extremely beneficial for workloads that want to
(1) explore task graph parallelism out of dynamic control flow
or 
(2) overlap task graph creation time with individual task execution time.
We recommend that you first read @ref AsyncTasking before this chapter.

@tableofcontents

@section CreateATaskGraphDynamically Create a Task Graph Dynamically

When the construct-and-run model of a task graph is not possible in your application,
you can leverage tf::Executor::dependent_async and tf::Executor::silent_dependent_async
to create a task graph dynamically.
This type of parallelism is also known as <i>on-the-fly task graph parallelism</i>,
which offers great flexibility for expressing task parallelism under complex control flow.
The example below dynamically creates a task graph of
four dependent tasks, @c A, @c B, @c C, and @c D, where @c A runs before @c B and @c C
and @c D runs after @c B and @c C:

@dotfile images/simple.dot

@code{.cpp}
tf::Executor executor;
tf::AsyncTask A = executor.silent_dependent_async([](){ printf("A\n"); });
tf::AsyncTask B = executor.silent_dependent_async([](){ printf("B\n"); }, A);
tf::AsyncTask C = executor.silent_dependent_async([](){ printf("C\n"); }, A);
auto [D, fuD] = executor.dependent_async([](){ printf("D\n"); }, B, C);
D.get();  // wait for D to finish, which in turns means A, B, C finish
@endcode

Calling both tf::Executor::dependent_async and tf::Executor::silent_dependent_async 
creates a task of type tf::AsyncTask to run the given function asynchronously,
while the former returns an additional @std_future that eventually holds the 
result of the execution.
When returning from the call, the executor has scheduled a worker 
to run the created task whenever its dependencies are met.
That is, task execution happens @em simultaneously 
with the creation of its task graph, which is different from constructing a %Taskflow
and running it from an executor.
Since this model only allows relating a dependency from the current task 
to a previously created task,
you need a correct topological order of graph expression.
For example, the code below shows another feasible 
order where @c C is created before @c B:

@code{.cpp}
tf::Executor executor;
tf::AsyncTask A = executor.silent_dependent_async([](){ printf("A\n"); });
tf::AsyncTask C = executor.silent_dependent_async([](){ printf("C\n"); }, A);
tf::AsyncTask B = executor.silent_dependent_async([](){ printf("B\n"); }, A);
auto [D, fuD] = executor.dependent_async([](){ printf("D\n"); }, B, C);
D.get();  // wait for D to finish, which in turns means A, B, C finish
@endcode

In our task graph, there are only two possible topological orderings,
@c ABCD or @c ACBD.

*/

}


